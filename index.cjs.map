{"version":3,"sources":["../src/utils.ts","../src/useHotkeys.ts","../src/useRecordHotkey.ts"],"names":["useRef","useEffect","target","useCallback","useState","display"],"mappings":"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","file":"index.cjs","sourcesContent":["import type { KeyCombination, KeyCombinationDisplay } from './types'\n\n/**\n * Detect if running on macOS\n */\nexport function isMac(): boolean {\n  if (typeof navigator === 'undefined') return false\n  return /Mac|iPod|iPhone|iPad/.test(navigator.platform)\n}\n\n/**\n * Normalize a key name to a canonical form\n */\nexport function normalizeKey(key: string): string {\n  // Handle special keys\n  const keyMap: Record<string, string> = {\n    ' ': 'space',\n    'Escape': 'escape',\n    'Enter': 'enter',\n    'Tab': 'tab',\n    'Backspace': 'backspace',\n    'Delete': 'delete',\n    'ArrowUp': 'arrowup',\n    'ArrowDown': 'arrowdown',\n    'ArrowLeft': 'arrowleft',\n    'ArrowRight': 'arrowright',\n    'Home': 'home',\n    'End': 'end',\n    'PageUp': 'pageup',\n    'PageDown': 'pagedown',\n  }\n\n  if (key in keyMap) {\n    return keyMap[key]\n  }\n\n  // Single characters to lowercase\n  if (key.length === 1) {\n    return key.toLowerCase()\n  }\n\n  // Function keys (F1-F12)\n  if (/^F\\d{1,2}$/.test(key)) {\n    return key.toLowerCase()\n  }\n\n  return key.toLowerCase()\n}\n\n/**\n * Format a key for display (platform-aware)\n */\nexport function formatKeyForDisplay(key: string): string {\n  const displayMap: Record<string, string> = {\n    'space': 'Space',\n    'escape': 'Esc',\n    'enter': '↵',\n    'tab': 'Tab',\n    'backspace': '⌫',\n    'delete': 'Del',\n    'arrowup': '↑',\n    'arrowdown': '↓',\n    'arrowleft': '←',\n    'arrowright': '→',\n    'home': 'Home',\n    'end': 'End',\n    'pageup': 'PgUp',\n    'pagedown': 'PgDn',\n  }\n\n  if (key in displayMap) {\n    return displayMap[key]\n  }\n\n  // Function keys\n  if (/^f\\d{1,2}$/.test(key)) {\n    return key.toUpperCase()\n  }\n\n  // Single letter - uppercase for display\n  if (key.length === 1) {\n    return key.toUpperCase()\n  }\n\n  return key\n}\n\n/**\n * Convert a KeyCombination to display format\n */\nexport function formatCombination(combo: KeyCombination): KeyCombinationDisplay {\n  const mac = isMac()\n  const parts: string[] = []\n  const idParts: string[] = []\n\n  // Order: Ctrl/Cmd, Alt/Option, Shift, Key\n  if (combo.modifiers.ctrl) {\n    parts.push(mac ? '⌃' : 'Ctrl')\n    idParts.push('ctrl')\n  }\n  if (combo.modifiers.meta) {\n    parts.push(mac ? '⌘' : 'Win')\n    idParts.push('meta')\n  }\n  if (combo.modifiers.alt) {\n    parts.push(mac ? '⌥' : 'Alt')\n    idParts.push('alt')\n  }\n  if (combo.modifiers.shift) {\n    parts.push(mac ? '⇧' : 'Shift')\n    idParts.push('shift')\n  }\n\n  parts.push(formatKeyForDisplay(combo.key))\n  idParts.push(combo.key)\n\n  return {\n    display: mac ? parts.join('') : parts.join('+'),\n    id: idParts.join('+'),\n  }\n}\n\n/**\n * Check if a key is a modifier key\n */\nexport function isModifierKey(key: string): boolean {\n  return ['Control', 'Alt', 'Shift', 'Meta'].includes(key)\n}\n\n/**\n * Parse a combination ID back to a KeyCombination\n */\nexport function parseCombinationId(id: string): KeyCombination {\n  const parts = id.toLowerCase().split('+')\n  const key = parts[parts.length - 1]\n\n  return {\n    key,\n    modifiers: {\n      ctrl: parts.includes('ctrl'),\n      alt: parts.includes('alt'),\n      shift: parts.includes('shift'),\n      meta: parts.includes('meta'),\n    },\n  }\n}\n","import { useEffect, useRef } from 'react'\nimport { isModifierKey, normalizeKey } from './utils'\n\n/**\n * Hotkey definition - maps key combinations to action names\n */\nexport type HotkeyMap = Record<string, string | string[]>\n\n/**\n * Handler map - maps action names to handler functions\n */\nexport type HandlerMap = Record<string, (e: KeyboardEvent) => void>\n\nexport interface UseHotkeysOptions {\n  /** Whether hotkeys are enabled (default: true) */\n  enabled?: boolean\n  /** Element to attach listeners to (default: window) */\n  target?: HTMLElement | Window | null\n  /** Prevent default on matched hotkeys (default: true) */\n  preventDefault?: boolean\n  /** Stop propagation on matched hotkeys (default: true) */\n  stopPropagation?: boolean\n  /** Enable hotkeys even when focused on input/textarea/select (default: false) */\n  enableOnFormTags?: boolean\n}\n\n/**\n * Parse a hotkey string into its components\n * e.g., \"ctrl+shift+k\" -> { ctrl: true, shift: true, key: \"k\" }\n */\nfunction parseHotkey(hotkey: string): {\n  ctrl: boolean\n  alt: boolean\n  shift: boolean\n  meta: boolean\n  key: string\n} {\n  const parts = hotkey.toLowerCase().split('+')\n  const key = parts[parts.length - 1]\n\n  return {\n    ctrl: parts.includes('ctrl') || parts.includes('control'),\n    alt: parts.includes('alt') || parts.includes('option'),\n    shift: parts.includes('shift'),\n    meta: parts.includes('meta') || parts.includes('cmd') || parts.includes('command'),\n    key,\n  }\n}\n\n/**\n * Check if a keyboard event matches a hotkey definition\n */\nfunction matchesHotkey(\n  e: KeyboardEvent,\n  hotkey: { ctrl: boolean; alt: boolean; shift: boolean; meta: boolean; key: string }\n): boolean {\n  const eventKey = normalizeKey(e.key)\n\n  return (\n    e.ctrlKey === hotkey.ctrl &&\n    e.altKey === hotkey.alt &&\n    e.shiftKey === hotkey.shift &&\n    e.metaKey === hotkey.meta &&\n    eventKey === hotkey.key\n  )\n}\n\n/**\n * Hook to register keyboard shortcuts.\n *\n * @example\n * ```tsx\n * useHotkeys(\n *   {\n *     't': 'setTemp',\n *     'c': 'setCO2',\n *     'ctrl+s': 'save',\n *     'shift+?': 'showHelp',\n *   },\n *   {\n *     setTemp: () => setMetric('temp'),\n *     setCO2: () => setMetric('co2'),\n *     save: () => handleSave(),\n *     showHelp: () => setShowHelp(true),\n *   }\n * )\n * ```\n */\nexport function useHotkeys(\n  keymap: HotkeyMap,\n  handlers: HandlerMap,\n  options: UseHotkeysOptions = {}\n): void {\n  const {\n    enabled = true,\n    target,\n    preventDefault = true,\n    stopPropagation = true,\n    enableOnFormTags = false,\n  } = options\n\n  // Use refs for handlers to avoid re-attaching listeners when handlers change\n  const handlersRef = useRef(handlers)\n  handlersRef.current = handlers\n\n  const keymapRef = useRef(keymap)\n  keymapRef.current = keymap\n\n  useEffect(() => {\n    if (!enabled) return\n\n    const targetElement = target ?? window\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Skip if focused on form element (unless enabled)\n      if (!enableOnFormTags) {\n        const target = e.target as HTMLElement\n        if (\n          target instanceof HTMLInputElement ||\n          target instanceof HTMLTextAreaElement ||\n          target instanceof HTMLSelectElement ||\n          target.isContentEditable\n        ) {\n          return\n        }\n      }\n\n      // Skip modifier-only keypresses\n      if (isModifierKey(e.key)) {\n        return\n      }\n\n      // Check each hotkey in the map\n      for (const [hotkeyStr, actionName] of Object.entries(keymapRef.current)) {\n        const hotkey = parseHotkey(hotkeyStr)\n\n        if (matchesHotkey(e, hotkey)) {\n          // Find the handler(s) for this action\n          const actions = Array.isArray(actionName) ? actionName : [actionName]\n\n          for (const action of actions) {\n            const handler = handlersRef.current[action]\n            if (handler) {\n              if (preventDefault) {\n                e.preventDefault()\n              }\n              if (stopPropagation) {\n                e.stopPropagation()\n              }\n              handler(e)\n              return // Only handle first match\n            }\n          }\n        }\n      }\n    }\n\n    targetElement.addEventListener('keydown', handleKeyDown as EventListener)\n\n    return () => {\n      targetElement.removeEventListener('keydown', handleKeyDown as EventListener)\n    }\n  }, [enabled, target, preventDefault, stopPropagation, enableOnFormTags])\n}\n","import { useCallback, useEffect, useRef, useState } from 'react'\nimport type { KeyCombination, RecordHotkeyOptions, RecordHotkeyResult } from './types'\nimport { formatCombination, isModifierKey, normalizeKey } from './utils'\n\n/** Store callback in ref to avoid effect re-runs when callback changes */\nfunction useEventCallback<T extends (...args: never[]) => unknown>(fn: T | undefined): T | undefined {\n  const ref = useRef(fn)\n  ref.current = fn\n  return useCallback(((...args) => ref.current?.(...args)) as T, [])\n}\n\n/**\n * Hook to record a keyboard shortcut from user input.\n *\n * When recording starts, captures the next key combination the user presses.\n * Recording completes when all keys are released after pressing a non-modifier key.\n *\n * @example\n * ```tsx\n * function KeybindingEditor() {\n *   const { isRecording, startRecording, combination, display, activeKeys } = useRecordHotkey({\n *     onCapture: (combo, display) => {\n *       console.log('Captured:', display.display)\n *       saveKeybinding(display.id)\n *     }\n *   })\n *\n *   return (\n *     <button onClick={() => startRecording()}>\n *       {isRecording\n *         ? (activeKeys ? formatCombination(activeKeys).display : 'Press keys...')\n *         : (display?.display ?? 'Click to set')}\n *     </button>\n *   )\n * }\n * ```\n */\nexport function useRecordHotkey(options: RecordHotkeyOptions = {}): RecordHotkeyResult {\n  const { onCapture: onCaptureProp, onCancel: onCancelProp, preventDefault = true } = options\n\n  // Stabilize callbacks to avoid effect re-runs\n  const onCapture = useEventCallback(onCaptureProp)\n  const onCancel = useEventCallback(onCancelProp)\n\n  const [isRecording, setIsRecording] = useState(false)\n  const [combination, setCombination] = useState<KeyCombination | null>(null)\n  const [activeKeys, setActiveKeys] = useState<KeyCombination | null>(null)\n\n  // Track pressed keys during recording\n  const pressedKeysRef = useRef<Set<string>>(new Set())\n  const hasNonModifierRef = useRef(false)\n  const currentComboRef = useRef<KeyCombination | null>(null)\n\n  const cancel = useCallback(() => {\n    setIsRecording(false)\n    setActiveKeys(null)\n    pressedKeysRef.current.clear()\n    hasNonModifierRef.current = false\n    currentComboRef.current = null\n    onCancel?.()\n  }, [onCancel])\n\n  const startRecording = useCallback(() => {\n    setIsRecording(true)\n    setCombination(null)\n    setActiveKeys(null)\n    pressedKeysRef.current.clear()\n    hasNonModifierRef.current = false\n    currentComboRef.current = null\n\n    // Return cancel function\n    return cancel\n  }, [cancel])\n\n  useEffect(() => {\n    if (!isRecording) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (preventDefault) {\n        e.preventDefault()\n        e.stopPropagation()\n      }\n\n      const key = e.key\n      pressedKeysRef.current.add(key)\n\n      // Build current combination from pressed keys\n      const combo: KeyCombination = {\n        key: '',\n        modifiers: {\n          ctrl: e.ctrlKey,\n          alt: e.altKey,\n          shift: e.shiftKey,\n          meta: e.metaKey,\n        },\n      }\n\n      // Find the non-modifier key\n      for (const k of pressedKeysRef.current) {\n        if (!isModifierKey(k)) {\n          combo.key = normalizeKey(k)\n          hasNonModifierRef.current = true\n          break\n        }\n      }\n\n      // Only update if we have a non-modifier key\n      if (combo.key) {\n        currentComboRef.current = combo\n        setActiveKeys(combo)\n      } else {\n        // Show modifiers being held\n        setActiveKeys({\n          key: '',\n          modifiers: combo.modifiers,\n        })\n      }\n    }\n\n    const handleKeyUp = (e: KeyboardEvent) => {\n      if (preventDefault) {\n        e.preventDefault()\n        e.stopPropagation()\n      }\n\n      pressedKeysRef.current.delete(e.key)\n\n      // On Mac, releasing Meta swallows other keyup events, so check if we have a valid\n      // combination when Meta is released (or when all keys are released)\n      const shouldComplete =\n        (pressedKeysRef.current.size === 0) ||\n        (e.key === 'Meta' && hasNonModifierRef.current)\n\n      if (shouldComplete && hasNonModifierRef.current && currentComboRef.current) {\n        const combo = currentComboRef.current\n        const display = formatCombination(combo)\n\n        // Clear state before callbacks to avoid re-entrancy issues\n        pressedKeysRef.current.clear()\n        hasNonModifierRef.current = false\n        currentComboRef.current = null\n\n        setCombination(combo)\n        setIsRecording(false)\n        setActiveKeys(null)\n\n        onCapture?.(combo, display)\n      }\n    }\n\n    // Capture phase to intercept before other handlers\n    window.addEventListener('keydown', handleKeyDown, true)\n    window.addEventListener('keyup', handleKeyUp, true)\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown, true)\n      window.removeEventListener('keyup', handleKeyUp, true)\n    }\n  }, [isRecording, preventDefault])\n\n  const display = combination ? formatCombination(combination) : null\n\n  return {\n    isRecording,\n    startRecording,\n    cancel,\n    combination,\n    display,\n    activeKeys,\n  }\n}\n"]}